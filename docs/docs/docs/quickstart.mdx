---
sidebar_position: 1
slug: /
title: Quickstart
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

# Quickstart

Build linux-like streamable and pipeable CLIs declaratively
using simple function closures. Easily compose smaller CLI
commands either programmatically or through CLI piping to build
larger tools.

## Install

```bash
$ npm install commandville -g
```

## First Command

<Tabs
  groupId="module-style"
  defaultValue="ESM"
  values={[
    {label: 'ESM', value: 'ESM'},
    {label: 'TypeScript', value: 'TS'},
    {label: 'CommonJS', value: 'CommonJS'},
  ]}>
<TabItem value="ESM">

<!-- prettier-ignore-start -->
```javascript title="~/my-project/index.mjs"

// Outer function recieves named flags and options.
export function greet({ excited, mark = '!', repeat = 1}) {

  // Inner closure recieves positional CLI arguments
  return function cli([greeting, name]) {
    const message = `${greeting}, ${name}${
      excited ? ''.padEnd(excited, mark) : '.'
    }\n`
    return ''.padEnd(message.length * repeat, message)
  }
}

// Define the CLI command name
// .command informs Commandville that this is a 
// function that should be hoisted as a CLI command.
greet.command = 'greet'

// Define command flags and options
// printed when using cmv <COMMAND> --help
greet.options = {
  excited: {
    type: 'count',
    aliases: ['e']
    description: 'Is it an exciting message?',
  },
  mark: {
    type: 'string',
    aliases: ['m']
    description: 'Punctuation mark to use for exciting messages.',
    default: '!',
  },
  repeat: {
    type: 'number',
    aliases: ['r'],
    description: 'Repeat the message x number of times.',
    default: 1,
    coerce: (val) => {
      if (val < 0) {
        throw new Error('Cannot repeat a message a negative n')
      }
      return Math.floor(val);
    }
  }
}
```

Commandville automatically hoists all exported function closures that define a `.command` property
within the current working directory. To run the `greet` command simply run `cmv greet`.

:::warning

To support [ES modules](https://nodejs.org/dist/latest-v14.x/docs/api/esm.html),
use the `.mjs` file extension or set the `type` field in `package.json` to `module`.
View [Determining module system](https://nodejs.org/dist/latest-v14.x/docs/api/packages.html#packages_determining_module_system)
for more information. Node ES modules also
[require using file extensions for relative import specifiers](https://nodejs.org/dist/latest-v14.x/docs/api/esm.html#esm_import_specifiers),
e.g., `import {something} from './relative/index.js`. Helpful gist on using
[pure ESM packages in node](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c).

:::

```bash title="~/my-project"
$ cmv greet Hello world -eee -r 2
# outputs
Hello, world!!!
Hello, world!!!
```

<!-- prettier-ignore-end -->

</TabItem>
<TabItem value="TS">

<!-- prettier-ignore-start -->
```typescript title="~/my-project/index.ts"

export interface GreetCliOptions {
  excited?: number;
  mark?: string;
  repeat?: number;
}

// Outer function recieves named flags and options.
export function greet({ 
  excited = 0, 
  mark = '!', 
  repeat = 1
  }: GreetCliOptions) {

  // Inner closure recieves positional CLI arguments
  return function cli([greeting, name]) {
    const message = `${greeting}, ${name}${
      excited ? ''.padEnd(excited, mark) : '.'
    }\n`
    return ''.padEnd(message.length * repeat, message)
  }
}

// Define the CLI command name
// .command informs Commandville that this is a 
// function that should be hoisted as a CLI command.
greet.command = 'greet'

// Define command flags and options
// printed when using cmv <COMMAND> --help
greet.options = {
  excited: {
    type: 'count',
    aliases: ['e']
    description: 'Is it an exciting message?',
  },
  mark: {
    type: 'string',
    aliases: ['m']
    description: 'Punctuation mark to use for exciting messages.',
    default: '!',
  },
  repeat: {
    type: 'number',
    aliases: ['r'],
    description: 'Repeat the message x number of times.',
    default: 1,
    coerce: (val) => {
      if (val < 0) {
        throw new Error('Cannot repeat a message a negative n')
      }
      return Math.floor(val);
    }
  }
}
```

Commandville automatically hoists all exported function closures that define a `.command` property
within the current working directory. To run the `greet` command simply run `cmv greet`.

:::warning

[TS-Node](https://www.npmjs.com/package/ts-node)
is required to run TypeScript files. Install TS-Node locally or globally
before running the following commandville command.
Alternatively, compile to JavaScript then run `cmv` in the resulting directory.

To run TypeScript files directly you must instruct node to use the TS-Node loader
by setting the `NODE_OPTIONS` environment variable before running the `cmv` command.
Instructions for setting environment variables differs between operating systems. 
Here we are using the [dotenv-cli](https://www.npmjs.com/package/dotenv-cli) 
package to set the environment variable which should work accross operating systems.

:::

```bash title="~/my-project"
$ npx dotenv -v NODE_OPTIONS='--loader ts-node/esm' -- cmv greet Hello world -eee -r 2
# outputs
Hello, world!!!
Hello, world!!!
```

<!-- prettier-ignore-end -->

</TabItem>
<TabItem value="CommonJS">

```javascript title="~/my-project/index.js"

// Outer function recieves named flags and options.
function greet({ excited, mark = '!', repeat = 1}) {

  // Inner closure recieves positional CLI arguments
  return function cli([greeting, name]) {
    const message = `${greeting}, ${name}${
      excited ? ''.padEnd(excited, mark) : '.'
    }\n`
    return ''.padEnd(message.length * repeat, message)
  }
}

// Define the CLI command name
// .command informs Commandville that this is a
// function that should be hoisted as a CLI command.
greet.command = 'greet'

// Define command flags and options
// printed when using cmv <COMMAND> --help
greet.options = {
  excited: {
    type: 'count',
    aliases: ['e']
    description: 'Is it an exciting message?',
  },
  mark: {
    type: 'string',
    aliases: ['m']
    description: 'Punctuation mark to use for exciting messages.',
    default: '!',
  },
  repeat: {
    type: 'number',
    aliases: ['r'],
    description: 'Repeat the message x number of times.',
    default: 1,
    coerce: (val) => {
      if (val < 0) {
        throw new Error('Cannot repeat a message a negative n')
      }
      return Math.floor(val);
    }
  }
}

module.exports = greet
```

Commandville automatically hoists all exported function closures that define a `.command` property
within the current working directory. To run the `greet` command simply run `cmv greet`.

```bash title="~/my-project"
$ cmv greet Hello world -eee -r 2
# outputs
Hello, world!!!
Hello, world!!!
```

</TabItem>
</Tabs>

Run `cmv --help` to see a list of all hoisted commands and associated help
messages for the current directory or run `cmv <COMMAND> --help` to see
command specific help.

:::info

The rest of this document will demonstrate commandville features using using ESM
modules but know that commandville supports hoisting ESM modules,
CommonJS modules and TypeScript modules

:::

## Piping

Commands hoisted by commandville automatically support piping.

```bash title="~/my-project"
$ echo "world" | cmv greet hello
# hello, world!
```

:::caution

In the above scenario, the entire process.stdin is gathered in memory
before being passed to the `cli` function. To fully support streaming,
the function closure needs to return a
[NodeJS Transform stream](https://nodejs.org/dist/latest-v14.x/docs/api/stream.html#stream_duplex_and_transform_streams).
More on that later.

:::

## CLI Options

Options are defined on the `.options` property of the function closure, as shown
previously. All options are gathered and passed to the function closure
as a plain object.

<!-- prettier-ignore-start -->

```javascript title="~/my-project/index.mjs"
export function helloWorld(flags) {
  return function cli([greet, name]) {
    console.log(flags)
    return `${greet}, ${name}!`
  }
}

helloWorld.command = 'hello-world'

helloWorld.options = {
  optionOne: {
    description: 'Option One.',
    type: 'string',
  },
  'option-two': {
    description: 'more options',
    type: 'number',
  },
}
```

<!-- prettier-ignore-end -->

Options may be defined using camelCase formatting or hyphenated names.
The `--help` menu preserves the defined style.

```bash title="~/my-porject"
$ cmv hello-world --help
#outputs
cmv hello-world

Options:
  --help        Show help                                              [boolean]
  --version     Show version number                                    [boolean]
  --optionOne   Option One                                              [string]
  --option-two  more options                                            [number]
```

Though the `--help` menu preserves the defined style, the CLI accepts both formatting styles and
the `flags` object will contain both formatting styles for every flag. In the following example,
the greet CLI is called with `optionOne` as a hyphenated flag and `option-two` as a camelCase flag,
the opposite of how they are defind in code.
Both options are actually availble within the flags object using either style.

```bash title="~/my-project"
$ cmv greet hello world --option-one cool --optionTwo 5
# outputs
{
  "option-one": "cool",
  "optionOne": "cool",
  "optionTwo": 5,
  "option-two": 5
}
hello, world!
```

View [command flags](references/flags) reference for a full list of option types
and configurations.

## Async Commands

Simply return an async function from the function closure.

```javascript title="~/my-project/index.mjs"
export function helloWorld(flags) {
  return async function cli([greet, name]) {
    // Do some async stuff...
    console.log(flags)
    return `${greet}, ${name}!`
  }
}

helloWorld.command = 'hello-world'
...
```

## Streaming Commands

To fully support argument streaming, return a
[NodeJS Transform stream](https://nodejs.org/dist/latest-v14.x/docs/api/stream.html#stream_duplex_and_transform_streams)
from the command closure.

```javascript title="~/my-project/streamer.mjs"
import { Transform } from 'stream'

export function streamingCommand(options) => {
  return new Transform({
    objectMode: true,
    transform(chunk, encoding, cb) {
      // Check if chunk is a buffer
      const isBuffer = Buffer.isBuffer(chunk)

      // convert chunk to string.
      const value = isBuffer ? chunk.toString('utf-8') : chunk

      console.log(`${value} is a buffer: ${isBuffer}`)

      // push the value to the next stream.
      // the last write stream in the pipe is stdout.
      this.push(value)
      cb()
    },
  })
}

streamingCommand.command = 'streamer'
```

Instead of recieving all arguments as an array of strings,
the transform stream will run for each incoming stream chunk.

```bash title="~/my-project"
$ cmv streamer hello world
# outputs
hello is a buffer: true
world is a buffer: true
```

Or

```bash title="~/my-project"
$ cat "some-large-file.ext" | cmv streamer
# outputs
chunk1 is a buffer: true
chunk2 is a buffer: true
chunk3 is a buffer: true
...
```

### Transform helper

`@commandville/transform` is a simple utlility for creating
Transform streams using functions. Returning a value automatically
pipes the value to the next stream in the pipe. There is no need
to call a callback function to indicate that the transform is complete,
the completion of the function is enough. `transform` also accepts
async functions, allowing for async transformations.

```javascript title="~/my-project/streamer.mjs"
import { transform } from '@commandville/transform'

export function streamingCommand(options) {
  return transform((chunk) => {
    // Check if chunk is a buffer
    const isBuffer = Buffer.isBuffer(chunk)

    // convert chunk to string.
    const value = isBuffer ? chunk.toString('utf-8') : chunk

    console.log(`${value} is a buffer: ${isBuffer}`)

    // send value to output stream
    return value
  })
}

streamingCommand.command = 'streamer'
```

Example of using `@commandville/transform` to
gather up stream chunks and output a single string at the end.

```javascript title="~/my-project/streamer.mjs"
import { transform } from '@commandville/transform'

export function streamingCommand(options) {
  const cliChunks = []
  return transform(
    (chunk) => {
      // Check if chunk is a buffer
      const isBuffer = Buffer.isBuffer(chunk)

      // convert chunk to string.
      const value = isBuffer ? chunk.toString('utf-8') : chunk

      // don't send individual chunks to output stream.
      // instead, build up chunks to output at the end.
      cliChunks.push(value)
    },
    () => {
      // This function runs at the end of the input stream
      // return all the input chunks as one string
      return cliChunks.join(' ')
    },
  )
}

streamingCommand.command = 'streamer'
```

```bash title="~/my-project"
$ cmv streamer hello world
# hello world
$ echo "lastName" | cmv streamer greetings firstName
# greetings firstName lastName
```

## Recommendations

Though simple function closures work for simple CLI use cases, the
streaming API not only supports streaming and piping in the shell
but it also supports programmatic composition, allowing one to build and distribute
larger CLI tools and pipelines composed of smaller CLI packages.
The streaming API is the most flexible and expressive in terms of the
problems it can address. For these reasons, we recommend using
`@commandville/transform` for building stream based CLI tools when possible.
